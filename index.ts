import { cwd } from 'process'
import { basename, join, resolve } from 'path'
import { watch } from 'fs/promises'
import { parseArgs } from 'util'

const pathToWatch = join(cwd(), 'package.ts')
const transpiler = new Bun.Transpiler({loader: 'ts'})

const collectImports = async () => {
  const collectImportsForFile = async (filePath: string): Promise<string[]> => {
    const imports = []
    for (const {path} of transpiler.scanImports(await Bun.file(filePath).text())){
      const fullPath = `${path}.ts`
      imports.push(fullPath)
      for (const childPath of await collectImportsForFile(fullPath)) {
        imports.push(childPath)
      }
    }
    return imports
  }
  return await collectImportsForFile(pathToWatch)
}
let pathsToWatch = [pathToWatch, ...await collectImports()]

const compile = async () => {
  const pkg = await import(pathToWatch)

  const defaults = () => ({
    ___meta: `This file is generated by code and should not be edited directly. Use 'package.ts instead to edit this file`,
    name: basename(cwd()),
    type: 'module',
    module: 'index.ts',
  })

  await Bun.write(
    join(cwd(), 'package.json'),
    JSON.stringify({
      ...defaults(),
      ...pkg.default,
    }),
  )
}
await compile()

const { values } = parseArgs({
  args: Bun.argv,
  options: {
    watch: {
      type: 'boolean',
      short: 'w',
    }
  },
  strict: false,
})

if (!values.watch) process.exit()

for await (const event of watch(cwd())) {
  if (event.eventType !== 'change') continue
  if (event.filename && !pathsToWatch.map(p => basename(p)).includes(event.filename)) continue

  pathsToWatch = [pathToWatch, ...await collectImports()]
  pathsToWatch.forEach(p => void delete require.cache[resolve(p)])
  await compile()
}
